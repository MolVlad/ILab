!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADD	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
AddStack	stack.c	/^Node * AddStack(Node * stack)$/;"	f
BIN_OPERATOR	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
BRACKET_CLOSE	lex.h	/^enum {BRACKET_OPENING, BRACKET_CLOSE, NEW_LINE, EQUALITY};	\/\/PUNCTUATION$/;"	e	enum:__anon5
BRACKET_OPENING	lex.h	/^enum {BRACKET_OPENING, BRACKET_CLOSE, NEW_LINE, EQUALITY};	\/\/PUNCTUATION$/;"	e	enum:__anon5
CONST	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
CopyTopStack	stack.c	/^Data CopyTopStack(Node * stack)$/;"	f
CreateStack	stack.c	/^Node * CreateStack()$/;"	f
CreateToken	lex.c	/^Token * CreateToken(Token * tokens, int type, int value)$/;"	f
DEGREE	lex.h	/^enum {PLUS, MINUS, DIVIDE, MULTIPLY, DEGREE};	\/\/ BIN_OPERATOR$/;"	e	enum:__anon2
DIV	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
DIVIDE	lex.h	/^enum {PLUS, MINUS, DIVIDE, MULTIPLY, DEGREE};	\/\/ BIN_OPERATOR$/;"	e	enum:__anon2
Data	stack.h	/^typedef int Data;$/;"	t
DeleteStack	stack.c	/^void DeleteStack(Node * stack)$/;"	f
DivStack	stack.c	/^Node * DivStack(Node * stack)$/;"	f
DotStack	stack.c	/^void DotStack(Node * stack)$/;"	f
DotToken	lex.c	/^void DotToken(Token * tokens)$/;"	f
EQUALITY	lex.h	/^enum {BRACKET_OPENING, BRACKET_CLOSE, NEW_LINE, EQUALITY};	\/\/PUNCTUATION$/;"	e	enum:__anon5
FUNCTION	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
FileToStr	lex.c	/^char * FileToStr()$/;"	f
GetG	run.c	/^int GetG(Token * tokens)$/;"	f
GetSemantics	lex.c	/^char * GetSemantics(Token * token)$/;"	f
IN	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
IsEmptyStack	stack.c	/^int IsEmptyStack(Node * stack)$/;"	f
IsEnd	run.c	/^int IsEnd(Token * tokens)$/;"	f
IsEquality	run.c	/^int IsEquality(Token * token)$/;"	f
IsNewStr	run.c	/^int IsNewStr(Token * tokens)$/;"	f
LexicalAnalysis	lex.c	/^Token * LexicalAnalysis(char * str)$/;"	f
MINUS	lex.h	/^enum {PLUS, MINUS, DIVIDE, MULTIPLY, DEGREE};	\/\/ BIN_OPERATOR$/;"	e	enum:__anon2
MUL	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
MULTIPLY	lex.h	/^enum {PLUS, MINUS, DIVIDE, MULTIPLY, DEGREE};	\/\/ BIN_OPERATOR$/;"	e	enum:__anon2
Minus	lex.c	2;"	d	file:
MulStack	stack.c	/^Node * MulStack(Node * stack)$/;"	f
NEW_LINE	lex.h	/^enum {BRACKET_OPENING, BRACKET_CLOSE, NEW_LINE, EQUALITY};	\/\/PUNCTUATION$/;"	e	enum:__anon5
NUMBER	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
Next	lex.h	/^	struct Token * Next;$/;"	m	struct:__anon6	typeref:struct:__anon6::Token
Next	stack.h	/^	struct Node * Next;$/;"	m	struct:Node	typeref:struct:Node::Node
Node	stack.h	/^typedef struct Node$/;"	s
Node	stack.h	/^} Node;$/;"	t	typeref:struct:Node
NodeToDot	stack.c	/^void NodeToDot(Node * stack)$/;"	f
Number	stack.h	/^	int Number;$/;"	m	struct:Node
OUT	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
PLUS	lex.h	/^enum {PLUS, MINUS, DIVIDE, MULTIPLY, DEGREE};	\/\/ BIN_OPERATOR$/;"	e	enum:__anon2
POP	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
PUNCTUATION	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
PUSH	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
Plus	lex.c	1;"	d	file:
PopStack	stack.c	/^Data PopStack(Node ** stack)$/;"	f
PopToken	lex.c	/^Token * PopToken(Token ** tokens)$/;"	f
PrintStack	stack.c	/^void PrintStack(Node * stack)$/;"	f
PushStack	stack.c	/^Node * PushStack(Node * stack, Data value)$/;"	f
RAX	lex.h	/^enum {RAX, RBX, RCX, RDX};	\/\/ REGISTER$/;"	e	enum:__anon3
RBX	lex.h	/^enum {RAX, RBX, RCX, RDX};	\/\/ REGISTER$/;"	e	enum:__anon3
RCX	lex.h	/^enum {RAX, RBX, RCX, RDX};	\/\/ REGISTER$/;"	e	enum:__anon3
RDX	lex.h	/^enum {RAX, RBX, RCX, RDX};	\/\/ REGISTER$/;"	e	enum:__anon3
REGISTER	lex.h	/^enum {BIN_OPERATOR, NUMBER, REGISTER, PUNCTUATION, FUNCTION, CONST};$/;"	e	enum:__anon1
Run	run.c	/^void Run(Token * tokens)$/;"	f
SUB	lex.h	/^enum {IN, OUT, PUSH, POP, ADD, SUB, MUL, DIV};	\/\/ FUNCTION$/;"	e	enum:__anon4
SizeOfFile	lex.c	/^int SizeOfFile(FILE * file)$/;"	f
SizeStack	stack.c	/^int SizeStack(Node * stack)$/;"	f
SubStack	stack.c	/^Node * SubStack(Node * stack)$/;"	f
Token	lex.h	/^} Token;$/;"	t	typeref:struct:__anon6
TokenToDot	lex.c	/^void TokenToDot(Token * token)$/;"	f
Type	lex.h	/^	int Type;$/;"	m	struct:__anon6
Value	lex.h	/^	int Value;$/;"	m	struct:__anon6
Value	stack.h	/^	Data Value;$/;"	m	struct:Node
WordSize	stack.c	1;"	d	file:
dot_semantics	lex.c	/^char * dot_semantics;$/;"	v
dot_token_counter	lex.c	/^int dot_token_counter;$/;"	v
file_dot_stack	stack.c	/^FILE * file_dot_stack;$/;"	v
file_dot_token	lex.c	/^FILE * file_dot_token;$/;"	v
main	comp.c	/^int main()$/;"	f
rax	run.c	/^int rax, rbx, rcx, rdx;$/;"	v
rbx	run.c	/^int rax, rbx, rcx, rdx;$/;"	v
rcx	run.c	/^int rax, rbx, rcx, rdx;$/;"	v
rdx	run.c	/^int rax, rbx, rcx, rdx;$/;"	v
sp	run.c	/^Node * sp = NULL;$/;"	v
